{
  "name": "secp256k1",
  "version": "1.1.6",
  "description": "This module provides native bindings to ecdsa secp256k1 functions",
  "main": "index.js",
  "scripts": {
    "test": "standard ./index.js && ./node_modules/mocha/bin/mocha --reporter spec ./test/",
    "install": "node-gyp rebuild",
    "rebuild": "node-gyp rebuild"
  },
  "dependencies": {
    "bindings": "^1.2.1",
    "nan": "^2.0.9"
  },
  "devDependencies": {
    "bigi": "^1.3.0",
    "coinkey": "^1.3.0",
    "ecdsa": "^0.6.0",
    "mocha": "^2.2.5",
    "node-gyp": "^3.0.3",
    "secure-random": "^1.1.1",
    "standard": "^5.2.2"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/wanderer/secp256k1-node.git"
  },
  "keywords": [
    "secp256k1",
    "ecdsa",
    "ec"
  ],
  "author": {
    "name": "martin becze",
    "email": "mjbecze@gmail.com"
  },
  "contributors": [
    {
      "name": "Aaron Davis",
      "url": "https://github.com/kumavis"
    },
    {
      "name": "Ian Matyssik",
      "url": "https://github.com/phpb-com"
    },
    {
      "name": "Kagami Hiiragi",
      "url": "http://kagami.genshiken.org/"
    },
    {
      "name": "ethers",
      "url": "https://github.com/ethers"
    },
    {
      "name": "Kirill Fomichev",
      "url": "https://github.com/fanatid"
    }
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/wanderer/secp256k1-node/issues"
  },
  "gypfile": true,
  "readme": "SYNOPSIS [![Build Status](https://travis-ci.org/wanderer/secp256k1-node.svg?branch=master)](https://travis-ci.org/wanderer/secp256k1-node)\n===\n\nThis module provides native bindings to ecdsa [secp256k1](https://github.com/bitcoin/secp256k1) functions.   \nThis library is experimental, so use at your own risk. Works on node version 0.11 or greater.\n\nINSTALL\n===\nIf you have gmp installed secp256k1 will use it. Otherwise it should fallback to openssl.\n* arch `pacman -S gmp`\n* ubuntu `sudo apt-get install libgmp-dev`\n\n##### from npm\n\n`npm install secp256k1`   \n\n##### from git\n\n`git clone git@github.com:wanderer/secp256k1-node.git`  \n`cd secp256k1-node`  \n`npm install` \n\nBROWSER\n===\nIf you want an compatiable API use [secp256k1-browserify](https://github.com/wanderer/secp256k1-browserify). Or use [elliptic](https://github.com/indutny/elliptic) directly\n\nUSAGE\n===\n```javascript\n\nvar ecdsa = require('secp256k1')\nvar crypto = require('crypto')\n\nvar privateKey = crypto.randomBytes(32)\n//a random message to sign\nvar msg = crypto.randomBytes(32)\n\n//get the public key in a compressed format\nvar pubKey = ecdsa.createPublicKey(privateKey, true)\n\n//sign the message\nvar sig = ecdsa.sign(msg, privateKey)\n\n//verify the signature\nif(ecdsa.verify(msg, sig, pubKey)){\n  console.log(\"valid signature\")\n}\n\n```\n\nTEST\n===\nrun `npm test`\n \nAPI\n===\n**Signature**\nAll functions that take signatures can take two formats\n* DER - which should be a repersented as an `Buffer`\n* Compact - which should be an `Object` with the following\n  - `signature` - a `Buffer`\n  - `recovery` - an `Integer` for the recovery id\n\nsecp256k1.verifySecretKey(secretKey) \n-----------------------------\nVerify an ECDSA secret key.\n\n**Parameters**\n\n* secretKey - `Buffer`, the secret Key to verify\n\n**Returns**: `Boolean`, `true` if secret key is valid, `false` secret key is invalid\n\nsecp256k1.verifyPublicKey(publicKey) \n-----------------------------\nVerify an ECDSA public key.\n\n**Parameters**\n\n* publicKey - `Buffer`, the public Key to verify\n\n**Returns**: `Boolean`, `true` if public key is valid, `false` secret key is invalid\n\nsecp256k1.sign(msg, secretkey, [DER], [cb]) \n-----------------------------\nCreate an ECDSA signature.\n\n**Parameters**\n\n* msg - `Buffer`,  a 32-byte message hash being signed \n* secretkey - `Buffer`, a 32-byte secret key (assumed to be valid)\n* DER - `Boolean`, **Optional**  if `true` the signature produced will be in DER format. Defaults to `false`\n* cb - `function`, **Optional** the callback. The callback is given the signature. If no callback is given the function will run sync.\n\n**Returns**:\n\n* if `DER` a `Buffer`, if no callback is given a 72-byte signature is returned  \n* else an compact siganture `Object`\n\nsecp256k1.verify(mgs, sig, pubKey, [cb]) \n-----------------------------\nVerify an ECDSA signature.  Runs asynchronously if given a callback\n\n**Parameters**\n* mgs - `Buffer`, the 32-byte message hash being verified\n* sig - `Buffer`, the signature being verified\n* pubKey - `Buffer`, the public key\n* cb - a callback if you want to run async\n \n**Returns**: Integer,  \n   - true correct signature\n   - false incorrect signature\n\nsecp256k1.recover(msg, sig, compressed, [cb]) \n-----------------------------\nRecover an ECDSA public key from a compact signature in the process also verifing it.  Runs asynchronously if given a callback\n\n**Parameters**\n* msg - `Buffer`, the message assumed to be signed\n* sig - `Buffer`, the signature\n* compressed - `Boolean`, whether to recover a compressed or uncompressed pubkey. Defaults to `true`\n* cb - `function`, Recover an ECDSA public key from a compact signature. In the process also verifing it.\n\n**Returns**: Buffer, the pubkey, a 33 or 65 byte buffer\n\nsecp256k1.createPublicKey(secKey, compressed) \n-----------------------------\nCompute the public key for a secret key.\n\n**Parameters**\n* secKey - `Buffer`, a 32-byte private key.\n* compressed - `Boolean`, whether the computed public key should be compressed\n\n**Returns**: Buffer, a 33-byte (if compressed) or 65-byte (if uncompressed).\n\nsecp256k1.exportPrivateKey(secretKey, compressed) \n-----------------------------\n\n**Parameters**\n* secretKey - `Buffer`\n* compressed - `Boolean`\n\n** Returns**: Buffer, privateKey\n\nsecp256k1.importPrivateKey(privateKey) \n-----------------------------\n\n**Parameters**\n* privateKey - `Buffer`\n\n**Returns**: `Buffer`, secretKey\n\nsecp256k1.decompressPublickey(secretKey) \n-----------------------------\n\n**Parameters**\n* secretKey - `Buffer`\n\n**Returns**: `Buffer`, This module provides native bindings to ecdsa [secp256k1](https://github.com/bitcoin/secp256k1) functions\n\nsecp256k1.privKeyTweakAdd(secretKey) \n-----------------------------\n**Parameters**\n* privateKey - `Buffer`\n* tweak - `Buffer`\n\n**Returns**: `Buffer`\n\nsecp256k1.privKeyTweakMul(privateKey, tweak) \n-----------------------------\n**Parameters**\n* privateKey - `Buffer`\n* tweak - `Buffer`\n\n**Returns**: Buffer\n\n\nLICENSE\n-----------------------------\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "secp256k1@1.1.6",
  "_from": "secp256k1@^1.1.5"
}
