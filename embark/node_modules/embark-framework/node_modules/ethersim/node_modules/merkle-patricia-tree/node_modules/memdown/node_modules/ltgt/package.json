{
  "name": "ltgt",
  "description": "implement correct ranges for level-*",
  "version": "1.0.2",
  "homepage": "https://github.com/dominictarr/ltgt",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/ltgt.git"
  },
  "dependencies": {},
  "devDependencies": {
    "tape": "~2.13.1"
  },
  "scripts": {
    "test": "node test.js"
  },
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "http://dominictarr.com"
  },
  "license": "MIT",
  "testling": {
    "files": "test.js",
    "browsers": [
      "ie/8..latest",
      "firefox/17..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# ltgt\n\nimplement correct ranges for level-*\n\n[![build status](https://secure.travis-ci.org/dominictarr/ltgt.png)](http://travis-ci.org/dominictarr/ltgt)\n[![testling badge](https://ci.testling.com/dominictarr/ltgt.png)](https://ci.testling.com/dominictarr/ltgt)\n\n# example\n\n\n``` js\nvar ltgt = require('ltgt')\n\nltgt.start(range) //the start of the range\nltgt.end(range)   //the end of the range\n\n//returns the lower/upper bound, whether it's inclusive or not.\nltgt.lowerBound(range)\nltgt.upperBound(range)\n\nltgt.lt(range)\nltgt.gt(range)\nltgt.lte(range)\nltgt.gte(range)\n\n//return wether this is a reversed order\n//(this is significant for start/end ranges\nltgt.reverse(range)\nvar filter = ltgt.filter(range)\n\nfilter(key) == true //if key contained in range.\n\nltgt.contains(range, key)\n\n```\n\n# ways to specify ranges\n\nthere have been a variety of ways to specify ranges in level-*.\nthis module supports them all.\n\n# gt/gte, lt/lte\n\nspecify a range between a lower bound (gt, gte) and an upper bound (lt, lte)\n\nif `gte` and `gt` is undefined, read from the start of the database,\nif `lte` and `lt` is undefined, read until the end of the database,\n\n\n# min, max\n\nlegacy level-sublevel style,\nsynonym for `gte`, `lte`.\n\n# start, end, reverse\n\nlegacy levelup style.\n\nThe range is from `start` -> `end`, `start` does not specify the lowest\nrecord, instead it specifies the first record to be read. However,\n`reverse` must also be passed correctly. This is way to specify a range is\nconfusing if you need to read in reverse,\nso it's strongly recommended to use `gt/gte,lt/lte`.\n\nIf `reverse` is `true`,\n`start` *must* be `undefined` or less than `end`,\nunless `end` is `undefined`.\n\nif `reverse` is `false`\n`end` *must* be `undefined` or greater than `start`,\nunless `start` is `undefined`.\n\nif start is undefined, read from the first record in the database\nif end is undefined read until the last record in the database.\n\n# api\n\n## ltgt.contains(range, key, compare)\n\nusing the provided compare method, return `true` if `key`\nis within `range`. compare defaults to `ltgt.compare`\n\n## ltgt.filter(range, compare)\n\nreturn a function that returns true if it's argument is within range.\ncan be passed to `Array.filter`\n\n``` js\n[1,2,3,4,5].filter(ltgt.filter({gt: 2, lte: 4})\n// => [3, 4]\n```\n\n## ltgt.lowerBound(range)\n\nreturn the lower bound of `range`.\nIncase the lower bound is specified with `gt`,\ncheck `ltgt.lowerBoundExclusive`\n\n## ltgt.upperBound(range)\n\nreturn the upperBound of `range`.\nIncase the upper bound is specified with `gt`,\ncheck `ltgt.upperBoundExclusive`\n\n## ltgt.lowerBoundExclusive(range)\n\nreturn true if upper bound is exclusive.\n\n## ltgt.upperBoundExclusive(range)\n\nreturn true if lower bound is exclusive.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/dominictarr/ltgt/issues"
  },
  "_id": "ltgt@1.0.2",
  "_from": "ltgt@~1.0.2"
}
